<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>2048 — Retro (Mobile Optimized)</title>
<style>
  :root{
    --bg:#111214;
    --panel:#1b1d21;
    --panel-2:#20232a;
    --text:#f7f7f7;
    --muted:#b8b8c2;
    --accent:#f7d354;
    --danger:#ff5566;
    --ok:#71e6a0;
    --grid:#2a2e36;
    --gap: clamp(6px, 2vw, 12px);
    /* Board size scales to viewport; max keeps it comfy on desktop */
    --size: min(92vw, 520px);
    --cell: calc((var(--size) - var(--gap)*3) / 4);
    --shadow: 0 10px 24px rgba(0,0,0,.35);
    --move-ms: 140ms;
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 20% -20%, rgba(255,255,255,.04), transparent 60%),
      radial-gradient(1200px 600px at 120% 120%, rgba(255,255,255,.04), transparent 60%),
      var(--bg);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    display:flex; align-items:center; justify-content:center;
    padding: max(16px, env(safe-area-inset-top)) 16px calc(20px + env(safe-area-inset-bottom));
    overscroll-behavior: contain;
  }

  .wrap{
    width: min(560px, 100%);
    display:flex; flex-direction:column; gap:12px;
  }

  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .title{ display:flex; align-items:baseline; gap:10px; line-height:1; }
  .title h1{
    margin:0; font-size: clamp(18px, 4.5vw, 24px); letter-spacing:.4px;
    text-shadow: 0 1px 0 #000, 0 0 3px rgba(247,211,84,.5), 0 0 8px rgba(247,211,84,.25);
  }
  .badge{
    padding:4px 8px; border-radius:999px;
    background:linear-gradient(180deg, #2a2d34, #1e2128);
    color:var(--accent); font-weight:700; font-size:12px;
    border:1px solid #3a3f49; box-shadow: var(--shadow);
  }

  .stats{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .chip{
    background:var(--panel); border:1px solid #2c313a; border-radius:10px;
    padding:8px 10px; min-width:88px; text-align:center; box-shadow: var(--shadow);
  }
  .chip b{ display:block; font-size: clamp(16px, 4vw, 18px); }
  .chip small{ color:var(--muted); }

  .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  button{
    appearance:none; border:none; cursor:pointer;
    background:linear-gradient(180deg, #353b45, #262b34);
    color:var(--text); padding:12px 16px; border-radius:12px;
    border:1px solid #3b4150; box-shadow: var(--shadow); font-weight:800;
    touch-action: manipulation; /* iOS: avoid double-tap zoom delay */
  }
  button:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; }
  .muted{ color:var(--muted); font-size:13px; }

  /* Board */
  .board-outer{
    position:relative;
    background:linear-gradient(180deg, var(--panel-2), var(--panel));
    padding: var(--gap);
    border-radius:14px; border:1px solid #2c313a;
    box-shadow: var(--shadow);
  }
  .board{
    position:relative;
    width: var(--size);
    height: var(--size);
    touch-action: none; /* allow custom swipe */
    margin:auto;
    overscroll-behavior: contain;
  }
  .grid{
    position:absolute; inset:0;
    display:grid; grid-template-columns: repeat(4, var(--cell));
    grid-template-rows: repeat(4, var(--cell));
    gap: var(--gap);
  }
  .cell{
    background:var(--grid);
    border-radius:12px;
    border:1px solid #3a3f49;
  }

  /* Tiles */
  .tiles{ position:absolute; inset:0; }
  .tile{
    position:absolute;
    width: var(--cell); height: var(--cell);
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; 
    /* Font scales with cell size; clamp keeps readable on tiny phones */
    font-size: clamp(18px, calc(var(--cell)*0.38), 40px);
    letter-spacing:.5px;
    transform: translate(var(--x), var(--y)) scale(1);
    transition: transform var(--move-ms) ease, box-shadow 120ms ease;
    will-change: transform;
    box-shadow: 0 6px 14px rgba(0,0,0,.35);
    user-select:none;
  }
  .v1024, .v2048 { font-size: clamp(14px, calc(var(--cell)*0.30), 34px); }
  .tile.bump{ animation: bump 120ms ease; }
  @keyframes bump{ 
    0%{ transform: translate(var(--x), var(--y)) scale(1); }
    50%{ transform: translate(var(--x), var(--y)) scale(1.06); }
    100%{ transform: translate(var(--x), var(--y)) scale(1); } 
  }

  /* Retro palette */
  .v2   { background:#3b3f47; color:#fafafa; }
  .v4   { background:#555b66; color:#fafafa; }
  .v8   { background:#7a5b28; color:#fff4d6; }
  .v16  { background:#9b6a2b; color:#fff4d6; }
  .v32  { background:#b9782f; color:#fff4d6; }
  .v64  { background:#d98633; color:#fff4d6; }
  .v128 { background:#7f3fb0; color:#f2eaff; }
  .v256 { background:#6b3fd9; color:#f0ecff; }
  .v512 { background:#3e58e3; color:#eef5ff; }
  .v1024{ background:#2aa8d1; color:#eafffb; }
  .v2048{ background:#f7d354; color:#2a2300; text-shadow:0 1px 0 #ffeaa6; }

  /* Banners */
  .banner{
    position:absolute; left:0; right:0; top: -12px;
    margin:auto; width:max-content; max-width:95%;
    background:linear-gradient(180deg, #2c313a, #21262e);
    border:1px solid #3a3f49; color:var(--text);
    padding:8px 12px; border-radius:999px; box-shadow: var(--shadow);
    display:none; align-items:center; gap:8px;
  }
  .banner.show{ display:flex; }
  .banner.win{ color:var(--ok); }
  .banner.lose{ color:var(--danger); }

  /* D-Pad shows only on touch devices (coarse pointers) */
  .dpad{ display:none; }
  @media (pointer: coarse){
    .dpad{
      display:grid; grid-template-columns:64px 64px 64px;
      grid-template-rows:64px 64px 64px; gap:10px;
    }
    .dpad button{ padding:0; width:64px; height:64px; border-radius:12px; font-size:24px; }
    .dpad .empty{ visibility:hidden; }
  }

  .help{ font-size:13px; color:var(--muted); line-height:1.5; }
  .row{ display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap; }

  .toggle{ display:flex; align-items:center; gap:8px; }
  .toggle input{ width:18px; height:18px; }

  .pixel { text-shadow: 0 1px 0 #000, 0 0 2px rgba(255,255,255,.05), 0 0 12px rgba(247,211,84,.2); }
</style>
</head>
<body>
  <main class="wrap" aria-label="2048 game page">
    <div class="topbar">
      <div class="title">
        <h1 class="pixel" aria-label="Game title">2048 — Retro</h1>
        <span class="badge" aria-hidden="true">MOBILE</span>
      </div>
      <div class="stats" role="group" aria-label="Score and time">
        <div class="chip" aria-live="polite"><small>SCORE</small><b id="score">0</b></div>
        <div class="chip"><small>BEST</small><b id="best">0</b></div>
        <div class="chip" aria-live="polite"><small>TIME</small><b id="time">00:00</b></div>
      </div>
    </div>

    <div class="row controls" role="group" aria-label="Game controls">
      <button id="btnNew" aria-label="Play or Restart game" title="Restart (R)">▶ Play / Restart</button>
      <div class="toggle">
        <input type="checkbox" id="soundToggle" aria-label="Toggle sound effects" />
        <label for="soundToggle" class="muted">Sound</label>
      </div>
      <span class="muted">Use arrows / swipe</span>
    </div>

    <section class="board-outer" aria-label="Game board region">
      <div id="banner" class="banner" role="status" aria-live="assertive">
        <span id="bannerText"></span>
        <button id="btnContinue" aria-label="Continue after win">Continue</button>
      </div>
      <div id="board" class="board" role="application" aria-label="2048 board" tabindex="0">
        <div class="grid" aria-hidden="true">
          <!-- 16 background cells -->
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
          <div class="cell"></div><div class="cell"></div><div class="cell"></div><div class="cell"></div>
        </div>
        <div id="tiles" class="tiles" aria-live="polite"></div>
      </div>
    </section>

    <div class="row" style="justify-content:space-between;">
      <div class="dpad" aria-label="On-screen arrow pad">
        <span class="empty"></span>
        <button id="up" aria-label="Move up">↑</button>
        <span class="empty"></span>
        <button id="left" aria-label="Move left">←</button>
        <span class="empty"></span>
        <button id="right" aria-label="Move right">→</button>
        <span class="empty"></span>
        <button id="down" aria-label="Move down">↓</button>
        <span class="empty"></span>
      </div>
      <div class="help">
        <b>How to play:</b> Merge tiles with the same number. Each move adds a new tile. Reach <b>2048</b> to win!  
        <br/>Keyboard: arrows (or R to restart). Touch: swipe. Buttons are focusable and labeled for screen readers.
      </div>
    </div>
  </main>

<script>
(() => {
  // ====== Core State ======
  const SIZE = 4;
  const PROB_4 = 0.10;
  const MOVE_MS = 140;
  let nextId = 1;
  let tiles = new Map(); // id -> {id, value, r, c}
  let score = 0;
  let best = Number(localStorage.getItem('best2048') || 0);
  let playing = false;
  let won = false;
  let locked = false;
  let startTime = null, timerHandle = null;

  // DOM refs
  const elScore = document.getElementById('score');
  const elBest = document.getElementById('best');
  const elTime = document.getElementById('time');
  const elTiles = document.getElementById('tiles');
  const elBoard = document.getElementById('board');
  const elBanner = document.getElementById('banner');
  const elBannerText = document.getElementById('bannerText');
  const elContinue = document.getElementById('btnContinue');
  const elBtnNew = document.getElementById('btnNew');
  const soundToggle = document.getElementById('soundToggle');

  elBest.textContent = best;

  // ====== Simple WebAudio beeps ======
  let audioCtx = null;
  function beep(type='move'){
    if(!soundToggle.checked) return;
    if(!audioCtx){ try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch{} }
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g).connect(audioCtx.destination);
    o.type = 'square';
    const now = audioCtx.currentTime;
    const f = (type==='merge') ? 740 : 420;
    o.frequency.setValueAtTime(f, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.2, now+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + (type==='merge'?0.18:0.12));
    o.start(now);
    o.stop(now + (type==='merge'?0.2:0.14));
  }

  // ====== Utilities ======
  function emptyCells(){
    const used = new Set([...tiles.values()].map(t=>`${t.r},${t.c}`));
    const list = [];
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      const key = `${r},${c}`;
      if(!used.has(key)) list.push([r,c]);
    }
    return list;
  }

  function addRandomTile(){
    const empties = emptyCells();
    if(!empties.length) return false;
    const [r,c] = empties[(Math.random()*empties.length)|0];
    const t = { id: nextId++, value: Math.random()<PROB_4 ? 4 : 2, r, c };
    tiles.set(t.id, t);
    return true;
  }

  function reset(){
    tiles.clear();
    nextId = 1;
    score = 0;
    updateScore(0);
    playing = true; won = false; locked=false;
    hideBanner();
    addRandomTile(); addRandomTile();
    startClock();
    render(true);
  }

  function startClock(){
    startTime = Date.now();
    if(timerHandle) clearInterval(timerHandle);
    timerHandle = setInterval(()=>{
      const s = Math.floor((Date.now()-startTime)/1000);
      const mm = String((s/60|0)).padStart(2,'0');
      const ss = String(s%60).padStart(2,'0');
      elTime.textContent = `${mm}:${ss}`;
    }, 200);
  }

  function stopClock(){
    if(timerHandle) clearInterval(timerHandle);
    timerHandle = null;
  }

  function showBanner(msg, type){
    elBannerText.textContent = msg;
    elBanner.classList.add('show');
    elBanner.classList.toggle('win', type==='win');
    elBanner.classList.toggle('lose', type==='lose');
  }
  function hideBanner(){
    elBanner.classList.remove('show','win','lose');
    elBannerText.textContent = '';
  }

  function updateScore(delta){
    score += delta;
    elScore.textContent = score;
    if(score > best){
      best = score;
      elBest.textContent = best;
      localStorage.setItem('best2048', best);
    }
  }

  function hasMoves(){
    if(emptyCells().length>0) return true;
    const byPos = Array.from(tiles.values()).reduce((m,t)=>{
      m[`${t.r},${t.c}`]=t.value; return m;
    },{});
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
      const v = byPos[`${r},${c}`];
      if(v==null) continue;
      if(r+1<SIZE && byPos[`${r+1},${c}`]===v) return true;
      if(c+1<SIZE && byPos[`${r},${c+1}`]===v) return true;
    }
    return false;
  }

  // ====== Rendering ======
  function render(initial=false){
    // Positions are based on CSS vars; we just map r,c to translate
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size'));
    const cell = (size - gap*3)/4;
    const px = (n)=> Math.round(n) + 'px';

    elTiles.innerHTML = '';
    for(const t of tiles.values()){
      const x = (cell + gap)*t.c;
      const y = (cell + gap)*t.r;
      const d = document.createElement('div');
      d.className = `tile v${t.value}`;
      d.style.setProperty('--x', px(x));
      d.style.setProperty('--y', px(y));
      d.textContent = t.value;
      d.setAttribute('aria-label', `Tile ${t.value} at row ${t.r+1} column ${t.c+1}`);
      elTiles.appendChild(d);
      if(initial){ d.classList.add('bump'); setTimeout(()=>d.classList.remove('bump'), 160); }
    }
  }

  function animatePositions(list){
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--size'));
    const cell = (size - gap*3)/4;
    const px = (n)=> Math.round(n) + 'px';

    elTiles.innerHTML = '';
    for(const t of list){
      const x = (cell + gap)*t.c;
      const y = (cell + gap)*t.r;
      const d = document.createElement('div');
      d.className = `tile v${t.value}`;
      d.style.setProperty('--x', px(x));
      d.style.setProperty('--y', px(y));
      d.textContent = t.value;
      d.dataset.id = t.id;
      elTiles.appendChild(d);
    }
  }

  // ====== Move Logic ======
  function move(direction){
    if(!playing || locked) return false;
    const drc = {left:[0,-1], right:[0,1], up:[-1,0], down:[1,0]}[direction];
    if(!drc) return false;

    const grid = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
    for(const t of tiles.values()) grid[t.r][t.c] = t.id;

    const order = [];
    if(direction==='left'){ for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) order.push([r,c]); }
    if(direction==='right'){ for(let r=0;r<SIZE;r++) for(let c=SIZE-1;c>=0;c--) order.push([r,c]); }
    if(direction==='up'){ for(let c=0;c<SIZE;c++) for(let r=0;r<SIZE;r++) order.push([r,c]); }
    if(direction==='down'){ for(let c=0;c<SIZE;c++) for(let r=SIZE-1;r>=0;r--) order.push([r,c]); }

    let moved = false;
    const mergedAt = new Set();

    for(const [r0,c0] of order){
      let id = grid[r0][c0];
      if(id==null) continue;
      let t = tiles.get(id);
      let r=r0, c=c0;
      while(true){
        const r1 = r + drc[0], c1 = c + drc[1];
        if(r1<0||r1>=SIZE||c1<0||c1>=SIZE) break;
        if(grid[r1][c1]==null){
          grid[r1][c1] = id; grid[r][c]=null; r=r1; c=c1; moved = true;
        }else{
          const otherId = grid[r1][c1];
          const other = tiles.get(otherId);
          const mkey = `${r1},${c1}`;
          if(other && other.value===t.value && !mergedAt.has(mkey)){
            grid[r][c]=null;
            grid[r1][c1]= -1;
            mergedAt.add(mkey);
            t.r = r1; t.c = c1;
          }
          break;
        }
      }
      if(grid[r][c]===id){
        t.r = r; t.c = c;
      }
    }

    if(!moved && mergedAt.size===0) return false;

    animatePositions([...tiles.values()]);
    locked = true;

    setTimeout(()=>{
      let gained = 0;
      const toDelete = [];
      const posMap = new Map();
      for(const t of tiles.values()){
        const key = `${t.r},${t.c}`;
        if(!posMap.has(key)) posMap.set(key, []);
        posMap.get(key).push(t);
      }
      for(const [key, arr] of posMap.entries()){
        if(arr.length>=2){
          arr.sort((a,b)=>a.id-b.id);
          const [a,b] = arr;
          if(a.value===b.value){
            const [r,c] = key.split(',').map(Number);
            toDelete.push(a.id, b.id);
            const merged = { id: nextId++, value: a.value*2, r, c };
            tiles.set(merged.id, merged);
            gained += merged.value;
          }
        }
      }
      for(const id of toDelete) tiles.delete(id);
      if(gained>0){ updateScore(gained); beep('merge'); }

      if(moved) addRandomTile();
      render();
      if(!won && [...tiles.values()].some(t=>t.value===2048)){
        won = true; showBanner('You win! 🎉', 'win');
      }
      if(!hasMoves()){
        playing = false; showBanner('Game over. Try again!', 'lose');
      }
      locked = false;
    }, MOVE_MS + 10);

    return true;
  }

  // ====== Input Handling ======
  function onKey(e){
    const k = e.key;
    if(k==='ArrowLeft'){ e.preventDefault(); move('left'); }
    else if(k==='ArrowRight'){ e.preventDefault(); move('right'); }
    else if(k==='ArrowUp'){ e.preventDefault(); move('up'); }
    else if(k==='ArrowDown'){ e.preventDefault(); move('down'); }
    else if(k==='r' || k==='R'){ e.preventDefault(); reset(); }
  }

  // D-Pad buttons
  [['up','up'],['down','down'],['left','left'],['right','right']].forEach(([id, dir])=>{
    const btn = document.getElementById(id);
    btn.addEventListener('click', ()=> move(dir));
  });

  // Swipe
  let tStart=null;
  elBoard.addEventListener('touchstart', (e)=>{
    if(e.touches.length!==1) return;
    const t = e.touches[0];
    tStart = { x:t.clientX, y:t.clientY };
  }, {passive:true});
  elBoard.addEventListener('touchend', (e)=>{
    if(!tStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - tStart.x;
    const dy = t.clientY - tStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    const TH = 24;
    if(Math.max(adx,ady) < TH){ tStart=null; return; }
    if(adx>ady){ move(dx<0?'left':'right'); } else { move(dy<0?'up':'down'); }
    tStart=null;
  }, {passive:true});

  // Focus board for keyboard play (desktop)
  elBoard.addEventListener('pointerdown', ()=> elBoard.focus());

  // Buttons
  document.getElementById('btnNew').addEventListener('click', reset);
  document.getElementById('btnContinue').addEventListener('click', ()=>{
    hideBanner(); playing = true; elBoard.focus();
  });

  // Global keyboard
  window.addEventListener('keydown', onKey, {passive:false});

  // Start immediately
  reset();

  // Resize listener to keep pixel-perfect placement when orientation changes
  window.addEventListener('resize', ()=>{ render(); }, {passive:true});

})();
</script>
</body>
</html>
